# distributed-lock-redis

分布式锁: Redis + Golang实现

分布式锁几个原则：
1. 「锁的互斥性」：在分布式集群应用中，共享资源的锁在同一时间只能被一个对象获取。
2. 「可重入」：为了避免死锁，这把锁是可以重入的，并且可以设置超时。
3. 「高效的加锁和解锁」：能够高效的加锁和解锁，获取锁和释放锁的性能也好。
4. 「阻塞、公平」：可以根据业务的需要，考虑是使用阻塞、还是非阻塞，公平还是非公平的锁。


基本流程:
1. 加锁: setNx(key, unqiueId, expire)
2. 操作共享资源
3. 释放锁: lua 脚本，先GET判断锁是否归属自己(unqiueId)，再DEL释放锁


几个重点考虑问题：
1. 释放他人锁：  
e.g. 客户端1操作共享资源完成后，却释放了客户端2的锁。因此在加锁时，需要考虑携带一个唯一标识(unqiueId)，例如UUID; 在释放锁时，需要判断该锁是否为自己持有。
即: 释放锁时先GET判断，再DEL删除。

2. redis操作的原子性：   
如上，先GET再DEL操作也会存在并发安全问题，因此需要确保这两个命令原子执行。这就是Lua脚本的完美适用场景。
Redis处理每一个请求是单线程执行的，在执行一个Lua脚本时，其它请求必须等待，直到这个Lua脚本处理完成，这样一来，GET+DEL之间就不会插入其它命令了。

3. 操作耗时>锁过期时间：   
实际业务场景中，在上锁后操作共享资源时，可能会遇到网络堵塞、请求超时等问题，导致操作耗时大于锁过期时间。
妥协方案: 尽量冗余过期时间，降低锁提前过期的概率。   
更好的方案: 加锁时，先设置一个过期时间，然后我们开启一个守护线程，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行续期，重新设置过期时间(e.g. Java Redisson)

存在弊端：  
若在redis集群环境下，对master节点申请了分布式锁，由于redis的主从同步是异步进行的，master在内存中写入了nx之后直接返回，客户端获取锁成功。
此时master节点挂了，并且数据还没来得及同步，另一个节点被升级为master，这样其他的线程依然可以获取锁。

参考： https://www.zhihu.com/question/452803310/answer/1931377239?utm_psn=1562944725060911104&utm_source=wechatMessage_answer_bottom 
